# jsvmp

## 遇到的一些问题:
问题1:变量池作用域问题 
已解决.每个函数重新进入enter函数时,会生成一个当前作用域的变量池,然后继承上一层作用域里的变量池.



## 遇到的一些坑:
if ((a = 1)) 目前在赋值语句后,会将堆栈索引+1, 然后不去判断会不会使用这个值, 可能存在bug.
var target = arguments[0] || {};

(b = se.aa = {'a':1,'c':'aaa','dd':{'ccc':'123'}}).dd.m = b.dd.ccc;
=> (b = se.aa = {'a':1,'c':'aaa','dd':{'ccc':'123'}}),b.dd.m = b.dd.ccc;
这种赋值需要针对,因为设计理念一开始就是从赋值右边开始运行.

(e = function a(){console.log(a);})();  闭包里的a对象是匿名函数.之前匿名函数遍历的时候都直接无视他的名称.

var a = b = 1;  这里的b是没有作用域的,是突然出现的,就直接默认定义在window下.

var a = {a : 1} => var a = {'a': 1};


## 一些思路:

思路1: 复制 push,slice,vm_call 函数, 且改变函数代码命名, 插入不同的奇怪代码. 最后改变bind, 达到抹去toString效果.

思路2: 复制字节码里的运行内容,插入死代码等方式混淆视听. 然后生成多个字节码对应这个指令, 这样的话, 就不能单独插桩某个地方.

思路3: 外层包裹一层init函数...

思路4: 复制几份计算代码,然后后续push堆栈的垃圾函数和正确函数都会传入不同值.

思路4: 怎么给普通函数加代码.


